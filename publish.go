package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
)

// Struct to hold OpenAI API request
type OpenAIRequest struct {
	Model    string        `json:"model"`
	Messages []GPTMessage  `json:"messages"`
}

// Struct for individual messages in the chat
type GPTMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// Struct for OpenAI API response
type OpenAIResponse struct {
	Choices []struct {
		Message struct {
			Content string `json:"content"`
		} `json:"message"`
	} `json:"choices"`
}

// Struct to correctly match the OpenAI response
type GPTTitleDescription struct {
	Title       string `json:"title"`
	Description string `json:"description"`
}

// Struct for GPT API response
type GPTResponse struct {
	Titles      []string `json:"titles"`
	Description string   `json:"description"`
}


func GenerateTitlesAndDescriptions(videoFile string) (*GPTResponse, error) {
	// Extract only the filename
	videoFileName := filepath.Base(videoFile) // Extracts "trump-annex-gaza-short.mp4"
	videoFileName = stripFileExtension(videoFileName) // Removes ".mp4"

	// Read transcription file from correct path
	transcriptionFile := fmt.Sprintf("./output/transcriptions/%s.txt", videoFileName)
	transcriptionText, err := ioutil.ReadFile(transcriptionFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read transcription file: %v", err)
	}

	// Get API key from environment
	apiKey := os.Getenv("OPENAI_API_KEY")
	if apiKey == "" {
		return nil, fmt.Errorf("missing OPENAI_API_KEY environment variable")
	}

	// Construct OpenAI API request
	requestBody := OpenAIRequest{
		Model: "gpt-4",
		Messages: []GPTMessage{
			{Role: "system", Content: "You generate video titles and a single description in JSON format."},
			{Role: "user", Content: fmt.Sprintf(
				"Based on this transcript, generate exactly 5 possible video titles that evoke emotion and curiosity and ONE single detailed description.\n\n"+
					"Return ONLY valid JSON. Example:\n"+
					"```json\n"+
					"{ \"titles\": [\"Title 1\", \"Title 2\", \"Title 3\", \"Title 4\", \"Title 5\"],"+
					" \"description\": \"This is the only detailed description provided.\" }"+
					"\n```"+
					"\n\nStrictly follow this format. DO NOT include anything else."+ 
					"\n\nTranscript:\n%s", string(transcriptionText))},
		},
	}

	// Convert requestBody to JSON
	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to encode OpenAI request: %v", err)
	}

	// Send request to OpenAI API
	req, err := http.NewRequest("POST", "https://api.openai.com/v1/chat/completions", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create OpenAI request: %v", err)
	}
	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send OpenAI request: %v", err)
	}
	defer resp.Body.Close()

	// Read response body
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read OpenAI response: %v", err)
	}

	// Extract content from GPT response
	var apiResponse OpenAIResponse
	err = json.Unmarshal(body, &apiResponse)
	if err != nil {
		log.Printf("Error parsing GPT response: %v\nRaw Output: %s", err, string(body))
		return nil, fmt.Errorf("failed to parse GPT response: %v", err)
	}

	// Extract GPT response text
	if len(apiResponse.Choices) == 0 {
		return nil, fmt.Errorf("no choices returned from GPT")
	}
	gptText := apiResponse.Choices[0].Message.Content

	// Debugging: Print raw GPT output
	fmt.Println("ðŸ” GPT Raw Response:")
	fmt.Println(gptText)

	// Remove possible triple backticks
	gptText = strings.TrimSpace(gptText)
	gptText = strings.TrimPrefix(gptText, "```json")
	gptText = strings.TrimSuffix(gptText, "```")

	// Parse GPT-generated JSON
	var gptResponse GPTResponse
	err = json.Unmarshal([]byte(gptText), &gptResponse)
	if err != nil {
		log.Printf("Error parsing GPT JSON response: %v\nRaw Output: %s", err, gptText)
		return nil, fmt.Errorf("failed to parse GPT JSON response: %v", err)
	}

	return &gptResponse, nil
}


// Utility function to remove file extension
func stripFileExtension(filename string) string {
	for i := len(filename) - 1; i >= 0; i-- {
		if filename[i] == '.' {
			return filename[:i]
		}
	}
	return filename
}

func PublishWithAutoGeneratedMetadata(videoPath, hashtags, platforms string) error {
	// Step 1: Transcribe the audio (No return value)
	TranscribeAudio(videoPath)

	// Step 2: Generate title and description using GPT
	fmt.Println("ðŸ¤– Generating possible titles and descriptions using GPT...")
	gptResponse, err := GenerateTitlesAndDescriptions(videoPath)
	if err != nil {
		return fmt.Errorf("failed to generate titles and descriptions: %v", err)
	}
	fmt.Println("âœ… Title and description suggestions generated!")

	// Extract titles (multiple) and description (single)
	titles := gptResponse.Titles
	description := gptResponse.Description // Now correctly extracted

	// Step 3: Display choices to user
	fmt.Println("\nðŸŽ¯ Suggested Titles:")
	for i, title := range titles {
		fmt.Printf("[%d] %s\n", i+1, title)
	}

	fmt.Println("\nðŸ“– Description:")
	fmt.Println(description)

	// Step 4: Let user select a title
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("\nEnter the number of the title you want to use: ")
	titleChoice, _ := reader.ReadString('\n')
	titleChoice = strings.TrimSpace(titleChoice)

	// Convert user input (string) to an integer safely
	titleIndex, err := strconv.Atoi(titleChoice)
	if err != nil || titleIndex < 1 || titleIndex > len(titles) {
		log.Fatalf("Invalid title selection: %s", titleChoice)
	}

	selectedTitle := titles[titleIndex-1]

	fmt.Printf("\nðŸ“¤ Proceeding with:\nTitle: %s\nDescription: %s\n", selectedTitle, description)

	// Step 5: Publish video
	err = PublishToPlatforms(videoPath, selectedTitle, description, hashtags, platforms)
	if err != nil {
		return fmt.Errorf("error publishing video: %v", err)
	}

	fmt.Println("âœ… Video successfully published!")
	return nil
}


// ParseJSONOutput parses GPT's JSON response into a Go map
func ParseJSONOutput(jsonStr string) map[string]string {
	var result map[string]string
	err := json.Unmarshal([]byte(jsonStr), &result)
	if err != nil {
		log.Fatalf("Error parsing GPT JSON response: %v", err)
	}
	return result
}

// CallGPTForTitlesAndDescriptions makes a request to the GPT API
func CallGPTForTitlesAndDescriptions(transcription string) (map[string]string, error) {
	prompt := fmt.Sprintf("Based on this transcript, suggest 5 possible video titles and 5 detailed descriptions:\n\n%s", transcription)

	cmd := exec.Command("python", "ask_gpt.py", prompt)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("GPT request failed: %v\n%s", err, output)
	}

	// Parse output (expecting JSON format)
	response := ParseJSONOutput(string(output))
	return response, nil
}

// PublishToPlatforms publishes a video to multiple platforms
func PublishToPlatforms(videoPath, title, description, hashtags, platforms string) error {
	platformList := strings.Split(platforms, ",")

	for _, platform := range platformList {
		switch strings.TrimSpace(platform) {
		case "youtube":
			err := PublishToYouTube(videoPath, title, description, hashtags)
			if err != nil {
				log.Printf("Failed to upload to YouTube: %v", err)
			}
		case "tiktok":
			err := PublishToTikTok(videoPath, title, description, hashtags)
			if err != nil {
				log.Printf("Failed to upload to TikTok: %v", err)
			}
		case "instagram":
			err := PublishToInstagram(videoPath, title, description, hashtags)
			if err != nil {
				log.Printf("Failed to upload to Instagram: %v", err)
			}
		case "twitter":
			err := PublishToTwitter(videoPath, title, hashtags)
			if err != nil {
				log.Printf("Failed to upload to Twitter: %v", err)
			}
		case "facebook":
			err := PublishToFacebook(videoPath, title, description, hashtags)
			if err != nil {
				log.Printf("Failed to upload to Facebook: %v", err)
			}
		case "linkedin":
			err := PublishToLinkedIn(videoPath, title, description)
			if err != nil {
				log.Printf("Failed to upload to LinkedIn: %v", err)
			}
		case "reddit":
			err := PublishToReddit(videoPath, title, description)
			if err != nil {
				log.Printf("Failed to upload to Reddit: %v", err)
			}
		default:
			log.Printf("Unknown platform: %s", platform)
		}
	}
	return nil
}

// PublishToYouTube uploads a video to YouTube
func PublishToYouTube(videoPath, title, description, hashtags string) error {
	cmd := exec.Command("python", "upload_youtube.py", videoPath, title, description, hashtags)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("YouTube upload failed: %v\n%s", err, output)
	}
	fmt.Println("YouTube upload successful!")
	return nil
}

// PublishToTikTok uploads a video to TikTok
func PublishToTikTok(videoPath, title, description, hashtags string) error {
	fmt.Println("Uploading to TikTok... (implement API call here)")
	return nil
}

// PublishToInstagram uploads a video to Instagram
func PublishToInstagram(videoPath, title, description, hashtags string) error {
	cmd := exec.Command("python", "upload_instagram.py", videoPath, title, description, hashtags)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("Instagram upload failed: %v\n%s", err, output)
	}
	fmt.Println("Instagram upload successful!")
	return nil
}

// PublishToTwitter uploads a video to Twitter
func PublishToTwitter(videoPath, title, hashtags string) error {
	cmd := exec.Command("python", "upload_twitter.py", videoPath, title, hashtags)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("Twitter upload failed: %v\n%s", err, output)
	}
	fmt.Println("Twitter upload successful!")
	return nil
}

// PublishToFacebook uploads a video to Facebook
func PublishToFacebook(videoPath, title, description, hashtags string) error {
	cmd := exec.Command("python", "upload_facebook.py", videoPath, title, description, hashtags)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("Facebook upload failed: %v\n%s", err, output)
	}
	fmt.Println("Facebook upload successful!")
	return nil
}

// PublishToLinkedIn uploads a video to LinkedIn
func PublishToLinkedIn(videoPath, title, description string) error {
	cmd := exec.Command("python", "upload_linkedin.py", videoPath, title, description)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("LinkedIn upload failed: %v\n%s", err, output)
	}
	fmt.Println("LinkedIn upload successful!")
	return nil
}

// PublishToReddit uploads a video to Reddit
func PublishToReddit(videoPath, title, description string) error {
	cmd := exec.Command("python", "upload_reddit.py", videoPath, title, description)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("Reddit upload failed: %v\n%s", err, output)
	}
	fmt.Println("Reddit upload successful!")
	return nil
}

